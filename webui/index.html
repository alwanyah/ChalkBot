<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>ChalkBot Web UI</title>
    </head>
    <body>
        <fieldset>
            <legend>Config</legend>
            <div>
                <label for="address">Address</label>
                <input id="address" type="text" value="192.168.0.231:8080">
                <button id="addressSet">set</button>
            </div>
        </fieldset>
        <fieldset>
            <legend>Pose</legend>
            <label for="poseAutoUpdate">Auto Update</label>
            <input id="poseAutoUpdate" type="checkbox" checked>
            <label for="poseUseGnss">use GNSS</label>
            <input id="poseUseGnss" type="checkbox">
            <span id="poseOutput">???</span>
        </fieldset>
        <fieldset>
            <legend>Sensors</legend>
            <label for="sensorsAutoUpdate">Auto Update</label>
            <input id="sensorsAutoUpdate" type="checkbox" checked>
            <p id="sensorsImu">???</p>
            <p id="sensorsGnss">???</p>
        </fieldset>
        <fieldset>
            <legend>Actions</legend>
            <label for="actionsAutoUpdate">Auto Update</label>
            <input id="actionsAutoUpdate" type="checkbox" checked>
            (TODO: Display stuff here)
        </fieldset>
        <fieldset>
            <legend>Drive</legend>
            <label for="driveForward">Forward (%)</label>
            <input id="driveForward" type="number" value="25">
            <label for="driveClockwise">Clockwise (%)</label>
            <input id="driveClockwise" type="number" value="0">
            <label for="drivePrint">Print (%)</label>
            <input id="drivePrint" type="number" value="0">
            <label for="driveDuration">Duration (s)</label>
            <input id="driveDuration" type="number" value="1">
            <button id="driveGo">Go</button>
        </fieldset>
        <fieldset>
            <legend>Goto</legend>
            <label for="gotoNorth">North (m)</label>
            <input id="gotoNorth" type="number" value="0">
            <label for="gotoEast">East (m)</label>
            <input id="gotoEast" type="number" value="0">
            <label for="gotoPrint">Print (%)</label>
            <input id="gotoPrint" type="number" value="0">
            <button id="gotoGo">Go</button>
        </fieldset>
        <fieldset>
            <legend>Canvas</legend>
            <canvas id="canvas" width="500" height="500" style="border: solid"></canvas>
            <table style="display: inline-block; vertical-align: top;">
                <tr>
                    <td><label for="canvasNorth">Offset North (m)</label></td>
                    <td><input id="canvasNorth" type="number" value="0"></td>
                </tr>
                <tr>
                    <td><label for="canvasEast">Offset East (m)</label></td>
                    <td><input id="canvasEast" type="number" value="0"></td>
                </tr>
                <tr>
                    <td><label for="canvasZoom">Zoom (px/m)</label></td>
                    <td><input id="canvasZoom" type="number" value="10">
                </tr>
                <tr>
                    <td></td>
                    <td><button id="canvasCenter">Center on Robot</button></td>
                </tr>
            </table>
        </fieldset>
        <fieldset>
            <legend>Control</legend>
            <input id="keyControl" type="text" placeholder="key control">
            <span id="gamepadOutput">Gamepad off</span>
        </fieldset>
        <script type="module">
            function DriveAction(forward, clockwise, print, duration) {
                return {
                    type: "drive",
                    properties: {
                        forward,
                        clockwise,
                        print,
                        duration,
                    },
                }
            }

            function GotoAction(north, east, print) {
                return {
                    type: "goto",
                    properties: {
                        north,
                        east,
                        print,
                    },
                }
            }

            self.ChalkBot = class ChalkBot {
                address

                constructor(address) {
                    this.address = address
                }

                async sensors() {
                    const response = await fetch(`//${this.address}/sensors`, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                        },
                    })
                    return await response.json()
                }

                async pose() {
                    const response = await fetch(`//${this.address}/pose`, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                        },
                    })
                    return await response.json()
                }

                async patchPose(pose) {
                    const response = await fetch(`//${this.address}/pose`, {
                        method: 'PATCH',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(pose),
                    })
                    return await response.json()
                }

                async actions() {
                    const response = await fetch(`//${this.address}/action_queue`, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                        },
                    })
                    return await response.json()
                }

                async replaceActions(actions) {
                    await fetch(`//${this.address}/action_queue`, {
                        method: 'PATCH',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            method: 'replace',
                            queue: actions,
                        }),
                    })
                }

                async appendActions(actions) {
                    const response = await fetch(`//${this.address}/action_queue`, {
                        method: 'PATCH',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            method: 'append',
                            queue: actions,
                        }),
                    })
                    return (await response.json()).appended
                }
            }

            self.UI = class UI {
                #elements = {
                    address: document.getElementById('address'),
                    addressSet: document.getElementById('addressSet'),

                    poseAutoUpdate: document.getElementById('poseAutoUpdate'),
                    poseOutput: document.getElementById('poseOutput'),
                    poseUseGnss: document.getElementById('poseUseGnss'),

                    sensorsAutoUpdate: document.getElementById('sensorsAutoUpdate'),
                    sensorsImu: document.getElementById('sensorsImu'),
                    sensorsGnss: document.getElementById('sensorsGnss'),

                    actionsAutoUpdate: document.getElementById('actionsAutoUpdate'),

                    driveForward: document.getElementById('driveForward'),
                    driveClockwise: document.getElementById('driveClockwise'),
                    drivePrint: document.getElementById('drivePrint'),
                    driveDuration: document.getElementById('driveDuration'),
                    driveGo: document.getElementById('driveGo'),

                    gotoNorth: document.getElementById('gotoNorth'),
                    gotoEast: document.getElementById('gotoEast'),
                    gotoPrint: document.getElementById('gotoPrint'),
                    gotoGo: document.getElementById('gotoGo'),

                    canvas: document.getElementById('canvas'),
                    canvasNorth: document.getElementById('canvasNorth'),
                    canvasEast: document.getElementById('canvasEast'),
                    canvasZoom: document.getElementById('canvasZoom'),
                    canvasCenter: document.getElementById('canvasCenter'),

                    keyControl: document.getElementById('keyControl'),
                    gamepadOutput: document.getElementById('gamepadOutput'),
                }

                #pose = null
                #sensors = null
                #actions = null

                #canvasContext
                #keys = {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                }
                #keysNeedUpdate
                #gamepad
                #gamepadTimestamp = 0
                #gamepadNeedUpdate

                chalkBot

                constructor(chalkBot) {
                    this.#canvasContext = this.#elements.canvas.getContext('2d')
                    this.chalkBot = new ChalkBot(this.#elements.address.value)
                    this.#elements.addressSet.addEventListener('click', () => this.#updateAddress())
                    this.#elements.poseUseGnss.addEventListener('click', () => this.#updateUseGnss())
                    this.#elements.driveGo.addEventListener('click', () => this.#drive())
                    this.#elements.gotoGo.addEventListener('click', () => this.#goto())
                    this.#elements.canvas.addEventListener('click', (event) => this.#gotoCanvas(event))
                    this.#elements.canvasCenter.addEventListener('click', () => this.#centerCanvasOnRobot())
                    this.#elements.keyControl.addEventListener('keydown', (event) => this.#keyDown(event))
                    this.#elements.keyControl.addEventListener('keyup', (event) => this.#keyUp(event))

                    this.#loop()
                    this.#gamepadLoop()
                }

                async #loop() {
                    try {
                        if (this.#elements.poseAutoUpdate.checked) {
                            this.#pose = await this.#updatePose()
                        } else {
                            this.#pose = null
                        }

                        if (this.#elements.sensorsAutoUpdate.checked) {
                            this.#sensors = await this.#updateSensors()
                        } else {
                            this.#sensors = null
                        }

                        if (this.#elements.actionsAutoUpdate.checked) {
                            this.#actions = await this.#updateActions()
                        } else {
                            this.#actions = null
                        }

                        this.#redrawCanvas()

                        if (this.#keysNeedUpdate) {
                            await this.#keyDrive()
                        }

                        if (this.#gamepadNeedUpdate) {
                            await this.#gamepadDrive()
                        }

                    } finally {
                        setTimeout(() => this.#loop(), 500)
                    }
                }

                async #updatePose() {
                    const pose = await this.chalkBot.pose()
                    this.#elements.poseUseGnss.checked = pose.useGnss
                    this.#elements.poseOutput.innerText = `north: ${pose.north.toFixed(3)}m, east: ${pose.east.toFixed(3)}m, heading: ${(pose.heading * 180 / Math.PI).toFixed(2)}°`

                    return pose
                }

                async #updateSensors() {
                    const sensors = await this.chalkBot.sensors()
                    const imu = sensors.imu
                    const gnss = sensors.gnss

                    if (imu === null) {
                        this.#elements.sensorsImu.innerText = 'IMU not found'
                    } else {
                        this.#elements.sensorsImu.innerText = `heading: ${imu.heading.toFixed(2)}°, roll: ${imu.roll.toFixed(2)}°, pitch: ${imu.pitch.toFixed(2)}°\n`
                            + `calib sys: ${imu.calibration.system}/3, gyro: ${imu.calibration.gyroscope}/3, accel: ${imu.calibration.accelerometer}/3, mag: ${imu.calibration.magnetometer}/3`
                    }

                    if (gnss === null) {
                        this.#elements.sensorsGnss.innerText = 'GNSS not found'
                    } else {
                        this.#elements.sensorsGnss.innerText = `satellites in view: ${gnss.satellites}, ntrip: ${gnss.ntripConnected}\n`
                            + `latitude: ${gnss.global.latitude.toFixed(7)}°N, longitude: ${gnss.global.longitude.toFixed(7)}°E, horizontal accuracy: ${gnss.global.horizontalAccuracy.toFixed(4)}m\n`
                            + `north: ${gnss.relative.north.toFixed(4)}m (acc ${gnss.relative.northAccuracy.toFixed(4)}m), east: ${gnss.relative.east.toFixed(4)}m (acc ${gnss.relative.eastAccuracy.toFixed(4)}m)\n`
                            + `heading: ${gnss.motion.heading.toFixed(2)}° (acc ${gnss.motion.headingAccuracy.toFixed(2)}°), north: ${gnss.motion.north.toFixed(3)}m/s, east: ${gnss.motion.east.toFixed(3)}m/s, speed: ${gnss.motion.speed.toFixed(3)}m/s (acc ${gnss.motion.speedAccuracy.toFixed(3)}m/s)`
                    }

                    return sensors
                }

                async #updateActions() {
                    const actions = await this.chalkBot.actions()

                    // TODO: show action queue and capacity

                    return actions
                }

                #redrawCanvas() {
                    const pose = this.#pose
                    const sensors = this.#sensors
                    const actionQueue = this.#actions?.queue ?? []

                    const width = this.#elements.canvas.width
                    const height = this.#elements.canvas.height
                    const northOffset = +this.#elements.canvasNorth.value
                    const eastOffset = +this.#elements.canvasEast.value
                    const zoom = +this.#elements.canvasZoom.value

                    this.#canvasContext.clearRect(
                        0,
                        0,
                        width,
                        height,
                    )

                    this.#canvasContext.beginPath()

                    if (pose !== null) {
                        const robotX = width / 2 + (pose.east - eastOffset) * zoom
                        const robotY = height / 2 - (pose.north - northOffset) * zoom

                        this.#canvasContext.arc(
                            robotX,
                            robotY,
                            10,
                            pose.heading - Math.PI / 4,
                            pose.heading + Math.PI * 5 / 4,
                        )
                        this.#canvasContext.moveTo(
                            robotX,
                            robotY,
                        )
                        this.#canvasContext.lineTo(
                            robotX + 15 * Math.sin(pose.heading),
                            robotY - 15 * Math.cos(pose.heading),
                        )
                    }

                    if (sensors !== null) {
                        const north = sensors.gnss.relative.north
                        const northAccuracy = sensors.gnss.relative.northAccuracy
                        const east = sensors.gnss.relative.east
                        const eastAccuracy = sensors.gnss.relative.eastAccuracy

                        for (let i = 1; i <= 4; ++i) {
                            const rectX = width / 2 + (east - i * eastAccuracy - eastOffset) * zoom
                            const rectY = height / 2 - (north + i * northAccuracy - northOffset) * zoom
                            const rectWidth = i * eastAccuracy * zoom * 2
                            const rectHeight = i * northAccuracy * zoom * 2

                            this.#canvasContext.strokeRect(rectX, rectY, rectWidth, rectHeight)
                        }
                    }

                    if (actionQueue.length !== 0 && actionQueue[0].type === 'goto') {
                        const { north, east } = actionQueue[0].properties

                        const targetX = width / 2 + (east - eastOffset) * zoom
                        const targetY = height / 2 - (north - northOffset) * zoom

                        this.#canvasContext.moveTo(
                            targetX - 10,
                            targetY - 10,
                        )
                        this.#canvasContext.lineTo(
                            targetX + 10,
                            targetY + 10,
                        )

                        this.#canvasContext.moveTo(
                            targetX - 10,
                            targetY + 10,
                        )
                        this.#canvasContext.lineTo(
                            targetX + 10,
                            targetY - 10,
                        )
                    }

                    this.#canvasContext.stroke()
                }

                async #gamepadLoop() {
                    try {
                        const gamepads = navigator.getGamepads()
                        if (gamepads.length === 0) {
                            return
                        }

                        this.#gamepad = gamepads[0]

                        if (this.#gamepadTimestamp !== this.#gamepad.timestamp) {
                            await this.#gamepadDrive()
                        }
                    } finally {
                        setTimeout(() => this.#gamepadLoop(), 100)
                    }
                }

                #updateAddress() {
                    this.chalkBot.address = this.#elements.address.value
                }

                async #updateUseGnss() {
                    await this.chalkBot.patchPose({
                        useGnss: this.#elements.poseUseGnss.checked
                    })
                }

                async #drive() {
                    const action = new DriveAction(
                        +this.#elements.driveForward.value / 100,
                        +this.#elements.driveClockwise.value / 100,
                        +this.#elements.drivePrint.value / 100,
                        +this.#elements.driveDuration.value,
                    )
                    await this.chalkBot.replaceActions([action])
                }

                async #goto() {
                    const north = +this.#elements.gotoNorth.value
                    const east = +this.#elements.gotoEast.value
                    const print = +this.#elements.gotoPrint.value / 100

                    const action = new GotoAction(north, east, print)
                    await this.chalkBot.replaceActions([action])
                }

                async #gotoCanvas(event) {
                    const width = this.#elements.canvas.width
                    const height = this.#elements.canvas.height
                    const northOffset = +this.#elements.canvasNorth.value
                    const eastOffset = +this.#elements.canvasEast.value
                    const zoom = +this.#elements.canvasZoom.value

                    const north = -(event.offsetY - height / 2) / zoom + northOffset
                    const east = (event.offsetX - width / 2) / zoom + eastOffset

                    const action = new GotoAction(north, east, 0)
                    await this.chalkBot.replaceActions([action])
                }

                async #centerCanvasOnRobot() {
                    const { north, east } = await this.chalkBot.pose()
                    this.#elements.canvasNorth.value = north
                    this.#elements.canvasEast.value = east
                }

                async #keyDrive() {
                    const action = new DriveAction(
                        (+this.#keys.up - +this.#keys.down) * 0.25,
                        (+this.#keys.right - +this.#keys.left) * 0.25,
                        0,
                        1,
                    )

                    this.#keysNeedUpdate =
                        this.#keys.up
                        || this.#keys.down
                        || this.#keys.left
                        || this.#keys.right

                    await this.chalkBot.replaceActions([action])
                }

                async #gamepadDrive() {
                    this.#gamepadTimestamp = this.#gamepad.timestamp

                    const forward = (-this.#gamepad.axes[1]) ** 3
                    const clockwise = this.#gamepad.axes[0] / 2
                    var print = this.#gamepad.axes[2]
                    if (print < 0) {
                        print = 0
                    }

                    this.#gamepadNeedUpdate =
                        forward !== 0
                        || clockwise !== 0
                        || print !== 0

                    if (this.#gamepadNeedUpdate) {
                        this.#elements.gamepadOutput.innerText = `Gamepad forward: ${forward}, clockwise: ${clockwise}, print: ${print}`
                    } else {
                        this.#elements.gamepadOutput.innerText = 'Gamepad off'
                    }

                    const action = new DriveAction(forward, clockwise, print, 1.0)
                    await this.chalkBot.replaceActions([action])
                }

                async #keyDown(event) {
                    switch (event.key) {
                        case 'ArrowUp':
                            this.#keys.up = true
                            break

                        case 'ArrowDown':
                            this.#keys.down = true
                            break

                        case 'ArrowLeft':
                            this.#keys.left = true
                            break

                        case 'ArrowRight':
                            this.#keys.right = true
                            break
                    }

                    event.preventDefault()
                    if (!event.repeat) {
                        await this.#keyDrive()
                    }
                }

                async #keyUp(event) {
                    switch (event.key) {
                        case 'ArrowUp':
                            this.#keys.up = false
                            break

                        case 'ArrowDown':
                            this.#keys.down = false
                            break

                        case 'ArrowLeft':
                            this.#keys.left = false
                            break

                        case 'ArrowRight':
                            this.#keys.right = false
                            break
                    }

                    await this.#keyDrive()
                }
            }

            document.addEventListener('DOMContentLoaded', () => self.ui = new UI)
        </script>
    </body>
</html>
